# Solution

### 문제 접근
- 해당 문제는 다익스트라의 특성을 잘 보여주는 문제이다.
- 횡단보도는 주어지는 순서대로 0 ~ m-1의 시작점(시간)을 가지고 m의 시간만큼을 주기로 하여 운용된다.
- 이 때, 1부터 n까지 갈 수 있는 최소 시간을 구하기 위해서는 각 node를 도착하는 시간을 기준으로 우선순위 큐에 넣어주어 다익스트라를 적용해야 한다.
  - 만일, 서로 다른 시간에 같은 node에 접근했다고 가정해보자.
  - 비교적 뒤에 node에 접근한 케이스는 먼저 접근한 케이스보다 도착지에 더 빨리 도착할 가능성은 __전무__ 하다.
  - 따라서, node에 접근했다는 여부를 visited 배열로 관리함으로써 필요하지 않은 케이스는 다 날려버려 리소스를 아낄 수 있다.
 
### 문제 풀이
- 위의 접근법을 다 코드에 적용했다면 어렵지 않게 풀 수 있다.

- 특이점은 Region 클래스에 해당 횡단보도를 건넌 후 시간을 구하는 메소드를 넣어주어 비교적 간단한 코드를 짤 수 있었다.
```java
long afterCrossTime(long nowTime) {
    if (nowTime % m == period) {
        return nowTime+1;
    }
    if (nowTime % m > period) {
        return m * (nowTime / m + 1) + period + 1;
    }
    return nowTime + (period - nowTime % m) + 1;
}
```

- 그리고, 위의 코드에서도 알 수 있다시피 시간을 long 타입으로 넣어주었어야 했다. 타입에 주의하자.

