# [Gold II] 환승 - 5214 

[문제 링크](https://www.acmicpc.net/problem/5214) 

### 성능 요약

메모리: 216208 KB, 시간: 1004 ms

### 분류

너비 우선 탐색(bfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### 문제 설명

<p>아주 먼 미래에 사람들이 가장 많이 사용하는 대중교통은 하이퍼튜브이다. 하이퍼튜브 하나는 역 K개를 서로 연결한다. 1번역에서 N번역으로 가는데 방문하는 최소 역의 수는 몇 개일까?</p>

### 입력 

 <p>첫째 줄에 역의 수 N과 한 하이퍼튜브가 서로 연결하는 역의 개수 K, 하이퍼튜브의 개수 M이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ K, M ≤ 1000)</p>

<p>다음 M개 줄에는 하이퍼튜브의 정보가 한 줄에 하나씩 주어진다. 총 K개 숫자가 주어지며, 이 숫자는 그 하이퍼튜브가 서로 연결하는 역의 번호이다. </p>

### 출력 

 <p>첫째 줄에 1번역에서 N번역으로 가는데 방문하는 역의 개수의 최솟값을 출력한다. 만약, 갈 수 없다면 -1을 출력한다.</p>


### 문제 풀이
<p> 너비 우선 탐색을 활용하는 문제였다. bfs를 통해 각 하이퍼튜브에 방문해서 거기에서 갈 수 있는 node를 큐에 추가해가면서 n이 나올 때까지 반복해주고 나오지 않는다면 -1을 반환하는 것이 핵심이었다.</p>
<p> 초반에 시간 초과에 걸렸었는데, 그 이유는 node에 대한 방문 배열만 만들어서 체크해주고 하이퍼튜브의 방문 배열은 따로 만들지 않았던 점이었다. 하이퍼튜브를 한 번 방문한다면 거기에 있node는 모두 방문하는 셈이므로 그 하이퍼튜브도 다시는 방문할 일이 없다는 점에 착안하여 visitedHyperTube 배열 또한 만들어주어 시간 안에 실행되는 코드를 완성할 수 있었다.</p>
<p> 시간 초과의 늪에서 벗어나기 위해서 할 수 있는 한 중복된 점을 생각하고 그 경우의 수를 줄이는 것이 최선이라는 교훈을 얻었다.</p>
