# [Gold I] 통신망 분할 - 17398 

[문제 링크](https://www.acmicpc.net/problem/17398) 

### 성능 요약

메모리: 48904 KB, 시간: 484 ms

### 분류

자료 구조(data_structures), 분리 집합(disjoint_set)

### 문제 설명

<p>BOJ의 인기스타, 방송인 권욱제는 통신 회사에 취업했다. 현재 이 통신 회사는 너무나 큰 통신망을 한 지사에서 관리하느라 큰 비용을 지불하고 있었다. 그래서 회사는 최근 IT의 트렌드 중 하나인 '탈중앙화'에 편승하여, 통신망을 분할하도록 결정했다. 그래서 욱제한테 통신망을 분할 할때 발생하는 비용을 분석하도록 지시했다.</p>

<p>현재 회사 망에는 1번부터 <em>N</em>번까지 총 <em>N</em>개의 통신 탑이 존재하며, 통신탑 간의 연결이 <em>M</em>개 존재한다. 이때 회사에서는 총 <em>Q</em>번 통신탑 간의 연결을 제거함으로써 하나의 통신망을 여러 개의 통신망으로 분리하려고 한다. 통신망이란, 통신탑의 연결을 통해 도달 가능한 통신탑들의 집합이다. 통신탑 간의 연결 관계를 제거할 때 드는 비용은 제거한 후 통신망이 두 개로 나누어진다면 나눠진 두 개의 통신망에 속한 통신탑들의 갯수의 곱이 되며, 나누어지지 않을 경우 0이다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/d75e532b-f1f9-4284-a0ef-8f06ad920998/-/preview/"></p>

<p style="text-align: center;"><그림 1></p>

<p>그림 1을 예시로 할때, 연결 (3, 4)를 제거하면 {1, 2, 3}, {4, 5, 6}으로 분할 되며, 이때 발생하는 비용은 3 × 3 = 9가 된다. 대신 연결 (2, 3)을 제거하면, 망이 나눠지지 않았기에 비용은 0이 된다.</p>

<p>욱제는 회사의 요청에 따라 <em>Q</em>번의 제거를 통해 나오는 비용의 합을 구해야 한다. 하지만 욱제는 회사의 통신망을 이용해 방송하기 바쁘기 때문에 우리가 도와주자.</p>

### 입력 

 <p>첫 번째 줄에는 통신탑의 개수인 자연수 <em>N</em>, 통신탑 사이의 연결의 개수인 자연수 <em>M</em>, 통신망 연결 분할 횟수인 자연수 <em>Q</em>가 공백으로 구분되어 주어진다. (1 ≤ <em>N</em> ≤ 100,000, 1 ≤ <em>M</em> ≤ 100,000, 1 ≤ <em>Q</em> ≤ <em>M</em>)</p>

<p>두 번째 줄부터 <em>M</em>개의 줄에 걸쳐 두 개의 자연수 <em>X</em>, <em>Y</em>가 공백으로 구분되어 주어진다. 이는 <em>X</em> 통신탑과 <em>Y</em> 통신탑 사이에 연결이 있음을 뜻한다. (1 ≤ <em>X</em>, <em>Y</em> ≤ <em>N, X </em>≠<i> Y</i>)</p>

<p>중복된 연결은 주어지지 않으며, 모든 통신탑은 처음엔 하나의 통신망에 속한다. 조건에 의해 자기 자신과 연결이 있는 통신탑은 없다.</p>

<p>그 다음 줄부터 <em>Q</em>개의 줄에 걸쳐 제거될 연결의 번호인 자연수 <em>A</em>가 주어진다. 이는 <em>A</em>번째로 입력된 (<em>X</em>, <em>Y</em>)의 연결이 제거되었음을 의미한다. (1 ≤ <em>A</em> ≤ <em>M</em>)</p>

<p>이미 제거된 연결은 다시 제거되지 않으며, 제거는 입력 순서대로 진행된다.</p>

### 출력 

 <p>첫 번째 줄에 <em>Q</em>개의 연결을 순서대로 제거하는데 드는 비용의 합을 출력한다.</p>

### 문제 풀이
<p>처음에 문제를 봤을 때, 유니온 파인드로 풀 수 있지 않을까 하는 감은 잡을 수 있었으나 union이 아닌 이를 분리하는 메소드는 본 적이 없기에 방향성에 난항을 겪었다. 하지만, 분리하는 과정을 완전히 뒤집어서 생각하면 곧 그게 union이고 문제에서 원하는 분리되고 난 뒤의 size의 곱도 합치기 전의 size의 곱과 동치라는 아이디어를 바탕으로 문제를 풀 수 있었다. </p>
<p> 1. 유니온파인드 메소드 구현, union 메소드 같은 경우에는 원래 두 점이 하나의 group이었다면 false를, 다른 group이었다면 true를 반환하여 분리했을 때 나누어지지 않으면 0을 더하라는 문제의 조건에 만족하는 background를 구성하였다. </p>
<p> 2. 분리되는 과정을 그대로 뒤집어서 코드에 적용할 것이기 때문에, 분리될 것들이 모두 분리된 상태의 uf 배열과 그에 따른 size 배열도 구성해 주었다. </p>
<p> 3. 분리되는 순서와 반대로 하여 union을 차례대로 해주면서 union 되기 전의 size의 곱을 출력되는 결과값인 변수 ans에 더해줌과 동시에 size 배열을 업데이트 해주었다. (값이 더해졌으므로) </p>
<p> 4. 여기서 주의해야할 점은 size의 곱에서 최댓값이 32비트 정수를 넘어가므로 64비트 타입인 long type을 사용하여 size 배열과 ans 변수를 정의하였다. </
