# [Gold II] 불켜기 - 11967 

[문제 링크](https://www.acmicpc.net/problem/11967) 

### 성능 요약

메모리: 25696 KB, 시간: 292 ms

### 분류

너비 우선 탐색(bfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### 문제 설명

<p>농부 존은 최근에 N × N개의 방이 있는 거대한 헛간을 새로 지었다. 각 방은 (1, 1)부터 (N,N)까지 번호가 매겨져있다(2 ≤ N ≤ 100). 어둠을 무서워하는 암소 베시는 최대한 많은 방에 불을 밝히고 싶어한다.</p>

<p>베시는 유일하게 불이 켜져있는 방인 (1, 1)방에서 출발한다. 어떤 방에는 다른 방의 불을 끄고 켤 수 있는 스위치가 달려있다. 예를 들어, (1, 1)방에 있는 스위치로 (1, 2)방의 불을 끄고 켤 수 있다. 베시는 불이 켜져있는 방으로만 들어갈 수 있고, 각 방에서는 상하좌우에 인접한 방으로 움직일 수 있다. </p>

<p>베시가 불을 켤 수 있는 방의 최대 개수를 구하시오.</p>

### 입력 

 <p>첫 번째 줄에는 N(2 ≤ N ≤ 1 00)과, M(1 ≤ M ≤ 20,000)이 정수로 주어진다.</p>

<p>다음 M줄에는 네 개의 정수 x, y, a, b가 주어진다. (x, y)방에서 (a, b)방의 불을 켜고 끌 수 있다는 의미이다. 한 방에 여러개의 스위치가 있을 수 있고, 하나의 불을 조절하는 스위치 역시 여러개 있을 수 있다. </p>

### 출력 

 <p>베시가 불을 켤 수 있는 방의 최대 개수를 출력하시오.</p>

### 문제 풀이
<p> 단순 bfs로 풀 수 있는 문제지만 한 가지 함정이 있다. 상하좌우 방향으로 1,1 좌표에서 시작해서 방문 여부와 불이 켜져있는지 여부를 쭉쭉 체크하면서 나가다 보면 결국에는 다다를 곳이 없게 되고 bfs가 끝날 것이다.</p>
<p> 하지만, 여기서 간과할 수 있는 부분은 불이 켜진 공간의 인접한 부분을 불이 켜지기 전에 지나는 것이다. 이렇게 된다면 불이 켜졌고 갈 수 있는 길이므로 count되어야 맞지만 방문 여부를 체크하면서 중복된 방문은 하지 않기 때문에 이미 지난 인접 부분을 재방문하여 불이 켜진 곳까지 가는 것은 불가능하다. </p>
<p> 따라서 도입한 방법은 불을 켤 때, 불이 켜진 곳의 인접 부분을 조사하여 인접한 공간이 방문 배열에 true로 저장되어 있다면 이 불이 켜진 곳도 방문할 수 있는 곳이라고 생각할 수 있으므로 queue에 추가하였다(물론 방문체크도 같이). 이렇게 함으로써 중복 체크를 함으로써 문제 조건에 만족하는 코드를 제출할 수 있었다.</p>
