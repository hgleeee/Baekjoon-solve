# [Gold II] 가장 긴 증가하는 부분 수열 2 - 12015 

[문제 링크](https://www.acmicpc.net/problem/12015) 

### 성능 요약

메모리: 121000 KB, 시간: 688 ms

### 분류

이분 탐색(binary_search), 가장 긴 증가하는 부분 수열: O(n log n)(lis)

### 문제 풀이

<p> 처음 문제를 봤을 때는 단순히 dp를 생각했었다. 하지만 문제를 보다나니 dp 배열로 2차원 배열이 필요하고 공간복잡도가 n의 제곱이 되는 것을 보고(n의 최댓값은 1000000) 다른 방법으로 풀어아햔다는 것을 깨달았다.</p>
 
<p> 이 문제를 풀기 위해서는 어떠한 trick이 필요했고 그 trick에 해당되는 것은 내 코드에서 답을 저장하는 역할이었던 list에는 오름차순과 size가 최대여야 한다는 조건, 그리고 정답으로 최대 길이를 원한다는 것을 힌트로 갖고 들어간다. 새로운 input을 가져와서 list에 넣을 때 만일 list에서 값이 가장 큰 last 값보다 input 값이 크다면 오름차순을 만족하므로 그대로 list의 뒤에 add 해주고, input 값이 작거나 같을 때는 list에서 input과 같거나 큰 수 중 가장 작은 값의 index를 찾아내어 그 index의 값을 input의 값으로 치환시켜버린다. </p>

<p> 위의 설명이 부실할 수 있으므로 예를 들어 설명하자면, 가장 긴 오름차순 수열을 찾아야 하는 arr가 {10, 20, 10, 30, 20, 50} 이라고 가정하고, list에는 0을 미리 넣어둔다. (처음 들어가는 arr[0] 값이 비교할 수 있는 대상이자 조건을 벗어나는 작은 값) 그리고 arr의 처음 index부터 마지막까지 루프를 돌리면서 위에서 설명했던 방식을 적용하는 것이다. 그렇다면 arr[0]이 들어갔을 때는 list의 요소는 0, 10, arr[1] : 0, 10, 20 , arr[2] : 0, 10, 20 (치환되었다), arr[3] : 0, 10, 20, 30, arr[4] : 0, 10, 20, 30 (치환되었다), arr[5] : 0, 10, 20, 30, 50 의 순서대로 list가 구성되고 따라서 정답은 총 size에서 0을 넣은 경우를 빼 준 4임을 알 수 있다.

<p> 생각의 착안점은 가장 긴 오름차순 수열의 길이를 찾는 데에 arr의 앞쪽 index에서 구성한 list보다 뒤의 index에서 구성한 list의 LIS가 길이가 짧으면서도 list의 요소의 값은 비교적 작을 수 있다는 것에 있다. {10, 20, 30, 1, 2, 3, 4} 이라는 arr에서 LIS를 구할 때 길이가 만약 {10,20,30}, {1,2,3} 으로 둘 모두 3으로 같다고 하더라도 뒤에 올 숫자들을 생각했을 때 1,2,3이 유리하다. 그리고 이분 탐색을 통해 {10, 20 ,30} 에 1이라는 값이 들어와 {1, 20, 30} 이 된다 한들 그 길이에 영향을 미치지도, 오름차순을 깨뜨리지도 않는다. </p>
