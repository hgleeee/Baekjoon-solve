# [Gold II] 벽 부수고 이동하기 4 - 16946 

[문제 링크](https://www.acmicpc.net/problem/16946) 

### 성능 요약

메모리: 73384 KB, 시간: 2260 ms

### 분류

너비 우선 탐색(bfs), 깊이 우선 탐색(dfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### 문제 설명

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.</p>

<p>각각의 벽에 대해서 다음을 구해보려고 한다.</p>

<ul>
	<li>벽을 부수고 이동할 수 있는 곳으로 변경한다.</li>
	<li>그 위치에서 이동할 수 있는 칸의 개수를 세어본다.</li>
</ul>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.</p>

### 출력 

 <p>맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.</p>


### 문제 풀이
<p> 이 문제는 각각의 벽을 부쉈을 때 이어져 있는 하나의 공간의 칸 수를 구하는 문제이다. 이 문제를 구하기 위해 space의 size를 구해주어야 했고, 깊이 우선 탐색을 통해 그 size를 구해주는 방식을 이용하였다. 그리고, 이를 효율적으로 구하기 위해서 벽을 부쉈을 때 일일이 dfs를 적용하는 것이 아니라 벽을 부수기 전의 초기 map 상태에서 각 공간에 indexing을 해주고 그 index에 따라 size를 알 수 있게끔 배열을 정의하여 dfs의 리턴값인 각 size를 배열에 저장시켰다. </p>
<p> 그리고, map의 각 node에 방문하여 벽이 아닌 경우에는 0으로, 벽인 경우에는 상하좌우 인접한 칸을 조사하여 벽이라면 0을 더하고 벽이 아닌 경우에는 해당 index를 가져와 size 배열에서 index를 통해 size를 더해주었고, 만일 index가 서로 겹치는 경우가 생긴다면 그 때는 무시해주었다. </p>
<p> 마지막으로 map을 출력하는데 있어서 처음에는 System.out.println 방식을 썼다가 시간 초과가 발생했고, 이를 타개하기 위해 StringBuilder를 활용해주었다. </p>
